You are a competitive programmer. You will be given the “Traveling Santa with Carrot Constraint” problem. Implement a C++17 solution that always outputs a valid tour and scales to the largest constraints. Follow every requirement below carefully; failing any validity rule may cause the judge to mark your output as Wrong Answer even if it looks close.

Task summary and input/output
- You are given N cities labeled 0..N−1 with 2D coordinates (xi, yi).
- City 0 is the North Pole.
- A tour is P of length N+1 with P0 = PN = 0 and P1..PN−1 being a permutation of 1..N−1.
- The Euclidean distance between cities a and b is dist(a,b) = sqrt((xa − xb)^2 + (ya − yb)^2).
- Carrot constraint:
  - Steps are indexed globally: for each step t = 1..N (moving from P[t−1] to P[t]).
  - If t is a multiple of 10 and P[t−1] is NOT prime, that step gets a 1.1 multiplier; else 1.0.
  - Primes are the standard primes over city IDs; 0 and 1 are not prime.
- Input format:
  - First line: N (2 ≤ N ≤ 200000).
  - Next N lines: xi yi for i = 0..N−1.
  - IMPORTANT: x is strictly increasing: x0 < x1 < ... < xN−1; City IDs equal input order.
- Output format:
  - First line: K, must be exactly N+1.
  - Next K lines: the city sequence P0..PN with P0 = PN = 0 and all cities 1..N−1 appearing exactly once in between.
- Distances and sums in double precision.
- Limits: Time limit 2 seconds; Memory limit 512 MB.

Critical correctness notes (step indexing and penalties)
- Steps are indexed globally and 1-based.
- A 10% penalty applies only when t is a multiple of 10 and the source city of that step (P[t−1]) is not prime.
- If you maintain an internal permutation S = [P1..P_{N−1}] (0-based), then step t maps to S-index j by:
  - For t = 1: edge 0 -> S[0]
  - For 2 ≤ t ≤ N−1: edge S[t−3] -> S[t−2]
  - For t = N: edge S[N−2] -> 0
  - Equivalently, positions in S that are the source of a potentially penalized step are j with j ≡ 8 (mod 10): j ∈ {8, 18, 28, ...} as long as 0 ≤ j ≤ N−2, because t = j + 2.
- City IDs 0 and 1 are not prime.

Performance requirements and recommended approach
- N can be up to 200k; O(N^2) is impossible. Target O(N log N) or O(N).
- Always produce a valid tour quickly; never output out-of-range IDs, duplicates, or miss any city.

Implementation plan
1) Fast I/O and data structures
   - Use ios::sync_with_stdio(false); cin.tie(nullptr);
   - Store coordinates in 64-bit integers (long long). Distances in double.
   - City struct: {int id; long long x, y;} if helpful.

2) Precompute primality up to N−1 with a sieve of Eratosthenes in O(N log log N).
   - Use a vector<char> isPrime of size N; mark 0 and 1 as non-prime.

3) Build an initial low-cost route S for cities 1..N−1:
   - Preferred: Hilbert curve ordering by (x, y):
     - Implement a 64-bit Hilbert index function (working with 32-bit per axis is fine since |coord| ≤ 1e9).
     - Optionally normalize/shift coordinates to unsigned space if needed; store the Hilbert key in 64-bit (or 128-bit if your implementation requires).
     - Sort cities 1..N−1 by Hilbert index.
   - Acceptable alternative (simpler and fast): block-based serpentine using input order (already x-sorted):
     - Partition cities 1..N−1 into fixed-size blocks by ID (e.g., B = 512 or 1024).
     - Within each block, sort by y ascending for even blocks and descending for odd blocks.
     - Concatenate the blocks in order to build S.

4) Carrot-aware adjustment (lightweight swaps only):
   - Let S be the vector of city IDs for P1..P_{N−1} (0-based).
   - For each target position j where a penalty could occur (j ≡ 8 mod 10):
     - If S[j] is already prime, skip.
     - Otherwise, search within a small symmetric window W around j (e.g., W = 50..100) for a position k where S[k] is prime.
     - For each candidate k, compute the local delta in total penalized tour length if swapping S[j] and S[k]. Consider only the affected edges:
       - With positions a = min(j,k), b = max(j,k), only steps i ∈ {a+1, a+2, b+1, b+2} can change (clamp to 1..N).
       - For each such step i, compute its endpoints before and after the swap:
         - If i == 1: edge 0 -> S[0]
         - Else if i == N: edge S[N−2] -> 0
         - Else: edge S[i−2] -> S[i−1]
         - When simulating a swap between indices a and b in S, map S[idx] to S[b] if idx==a, to S[a] if idx==b, else S[idx].
       - For each endpoint pair, multiply dist by the correct step multiplier based on the source city at that step and whether i % 10 == 0.
     - Choose the k with the most negative (best) delta among candidates in the window; if none improves but you still want the prime at j, you may accept the least-bad swap only if its delta is small. To keep time under 2s, cap the number of evaluated candidates per j (e.g., MAX_CANDS = 20).
     - Handle adjacency (k == j±1) and ends (j == 0 or j == N−2) correctly by using city 0 as the neighbor where applicable.
     - If no prime is found in the window, skip the adjustment for that j.
   - This step must be O(N * W) with small constants.

5) Optional small-budget local improvement (only if time allows):
   - A few iterations of bounded 2-opt or adjacent 3-opt inside a small window around j’s can help.
   - Keep the total time under the 2-second limit; skip entirely if timing is tight.

6) Robust validation and guaranteed fallback (O(N)):
   - Verify S has exactly N−1 elements.
   - Verify every element of S is an integer in [1..N−1] and appears exactly once.
   - If anything fails, rebuild S deterministically as the identity permutation [1,2,...,N−1].
   - Never include 0 inside S. The only 0s in the final output must be the first and last entries of P.

7) Output formatting (strict):
   - Print exactly K = N+1 on the first line.
   - Then print the tour:
     - Line 1 after K: 0
     - Next N−1 lines: S[0], S[1], ..., S[N−2]
     - Final line: 0
   - One integer per line; no extra spaces or lines.

Edge cases and notes
- N < 10: no penalty steps (since no t multiple of 10). The adjustment loop should naturally do nothing.
- Very small N (e.g., N=2): still output K=N+1 with route 0, 1, 0.
- Distances and sums in double precision are sufficient; for comparing local deltas you can use doubles consistently.
- City IDs equal input order and x is strictly increasing; this can make a simple x-block serpentine surprisingly strong as a baseline.
- Keep everything iterative (no deep recursion), O(N) memory.

Coding requirements
- Use C++17.
- Use fast I/O (ios::sync_with_stdio(false); cin.tie(nullptr);).
- Implement the sieve, Hilbert (or serpentine) ordering, local swap logic with correct step multipliers, robust validation, and strict output formatting.
- Keep runtime within ~2 seconds for N up to 200k; tune W and candidate caps accordingly.

Your response must be ONLY the C++ code, wrapped in:
```cpp
// code
```
No extra text or explanations outside the code block.