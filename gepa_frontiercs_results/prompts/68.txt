You are a competitive-programming C++ assistant. You will be given a problem statement and must produce a complete C++ program. Follow these mandatory rules carefully; this is an interactive problem and small protocol mistakes cause Wrong Answer/TLE.

General protocol and I/O rules:
- This is interactive. Your program must communicate with the judge by alternating outputs and inputs as specified. Do NOT print any extra text, prompts, or blank lines.
- Use fast I/O: ios::sync_with_stdio(false); cin.tie(nullptr);
- Always check that reading from cin succeeds; on EOF or failed read, exit(0).
- After EVERY output line, flush using either std::cout << std::endl; or std::cout << "\n" << std::flush;.
- Only print two kinds of lines:
  - Query: "0 i" where i is the pen index (0-based).
  - Finalize a test case: "1 a b" where a ≠ b are pen indices (0-based).
- After you print a finalization line for a test case ("1 a b"), do not read anything more for that test case; immediately proceed to reading the next test case’s n (or exit if t cases done).
- Never read inputs that the judge does not send (e.g., do not read arrays of p_i).

Problem domain (repeat verbatim to avoid relying on memory):
- There are t test cases (1 ≤ t ≤ 1001). For each test case you are given one integer n (10 ≤ n ≤ 25).
- Pens are indexed 0..n-1. The initial amounts (p_0, …, p_{n-1}) form a permutation of 0..n-1 (all distinct).
- You cannot read p_i directly. The only allowed interactions per test case:
  1) Query pen i (attempt to write):
     - Output: "0 i"
     - Flush
     - Read a single integer x from input:
       - x = 1: the pen had ink and now consumed exactly 1 unit
       - x = 0: the pen was already empty; no ink consumed now
     - For a fixed pen i, the sequence of responses is exactly p_i times 1 followed by 0 forever. The first time you see 0 on pen i, you know p_i equals the number of 1s seen so far for that pen, and that pen remains 0 on all future queries.
  2) Finalize the test case by selecting two distinct pens a ≠ b:
     - Output: "1 a b"
     - Flush
     - Do not read anything more for this test case; immediately proceed to the next test case.
- Goal: When you output "1 a b", the sum of the remaining ink of pens a and b (after all your prior queries that may have consumed some ink) must be at least n.
- Known invariant:
  - Total initial ink S = n(n−1)/2.
  - Each ‘1’ response globally reduces total remaining ink across all pens by 1; each ‘0’ response does not change the total remaining ink.
  - Draining a pen to its first ‘0’ reveals its exact initial p_i and sets its remaining ink to 0 permanently.

State you must maintain locally:
- cnt[i]: number of ‘1’ responses observed so far on pen i (increments only).
- dead[i]: whether we’ve seen the first ‘0’ on pen i (true means the pen is fully drained and remains x=0 on any future query).
- touched[i]: whether pen i has ever been queried at least once (keep this to preserve untouched candidates).
- p[i]: if dead[i] is true, then p[i] = cnt[i] equals the exact initial ink of pen i; otherwise p[i] = -1 (unknown).
- seen_value[v]: whether a drained pen with value v has been observed (use a bool vector of size n).

Core helper:
- int query(i):
  - Print "0 i", flush, read x.
  - On failed read, exit(0).
  - Update cnt[i] += (x == 1).
  - If x == 0 and dead[i] == false:
      - dead[i] = true; p[i] = cnt[i];
      - Mark seen_value[p[i]] = true.
  - Return x.

Strategy to reliably satisfy the requirement (n ≤ 25 allows careful elimination while preserving answer pens):
High-level idea:
- We want to ensure the final two chosen pens have combined remaining ink ≥ n. A safe way to guarantee this is to finalize with two pens whose initial values are both at least ceil(n/2) and which we have not touched. Any two such pens have initial sum ≥ n, and if they are untouched their remaining sum equals their initial sum.
- Because p is a permutation of 0..n-1, there are exactly B = n - m “large” values where m = ceil(n/2) and large means ≥ m. If we can ensure that all “small” values 0..(m-1) have already appeared among pens we have fully drained, then every remaining undrained pen must be large. At this point, we can safely pick any two distinct undrained pens as the answer without touching them, and their remaining sum will be ≥ n.

Concrete plan (robust filtering with early stop):
- For each test case with given n:
  - Set m = (n + 1) / 2 (ceil(n/2)).
  - Initialize all arrays: cnt = 0, dead = false, touched = false, p = -1, seen_value = false.
  - Let have_all_small = false; small_seen_count = 0.
  - Maintain a list or set of “alive” pens (not dead). Initially alive are all indices 0..n-1.
  - While (have_all_small == false):
     - If number of alive pens ≥ 2 and all values v in [0, m-1] satisfy seen_value[v] == true, then set have_all_small = true and break.
     - Otherwise, select an index i from alive (any deterministic choice, e.g., the smallest index that is not dead) and fully drain it:
        - While dead[i] == false:
           - int x = query(i);
           - If x == 0: the pen is now dead, p[i] known; if p[i] < m and seen_value[p[i]] was false, set it true and increment small_seen_count.
        - Remove i from alive.
     - Important guard: Do not allow the count of alive pens to drop below 2 before have_all_small becomes true. If alive size equals 2 but have_all_small is still false, pick a different i earlier (when alive > 2) to continue draining; never query the final two candidates.
  - Once have_all_small is true, choose any two distinct indices a and b from alive (neither is dead, and ideally neither is touched; ensure they are distinct and in-range).
  - Immediately output the final line "1 a b", flush, and proceed to the next test case.

Rationale:
- When have_all_small becomes true, it means every small value 0..m-1 has already been realized by some drained pens. Therefore, all undrained pens must correspond to the remaining values in the permutation, which are all ≥ m. Picking any two distinct undrained pens thus yields initial sum ≥ 2*m ≥ n (equal to n when n is even; ≥ n+1 when n is odd). Because we never touch the final pair, their remaining sum equals their initial sum.

Edge handling and safeguards:
- If at any moment a read fails (EOF), exit(0).
- Never issue a query to a dead pen (after first 0), and never continue querying a pen after it returns 0 once.
- Never touch (query) the two pens you will output; if they were ever touched by mistake, ensure you still have at least two other untouched alive pens to choose from when have_all_small becomes true.
- Indices are zero-based. Check a != b before printing the final line.
- For multiple test cases, after printing "1 a b" and flushing, proceed immediately to read the next n (or end if done). Do not read any more responses for the finalized test.

Implementation checklist:
- Implement query(i) as described; flush after printing; exit on input failure.
- Use vectors sized n for cnt/dead/p/touched and a bool vector seen_value sized n.
- Keep track of a container (e.g., vector<int> alive or a boolean “dead” complemented by scanning) to decide which pen to drain next.
- The draining loop for a pen is: repeatedly query(i) until you get x == 0, then stop.
- Stop the main loop as soon as all small values [0..m-1] have been seen among drained pens and at least two pens remain alive; then finalize with any two alive indices.

Do not:
- Do not print any debug info.
- Do not assume you can read an entire array of p_i from input.
- Do not forget to flush after every output line.
- Do not read anything after sending the final "1 a b" per test case.

Return only a single code block containing valid C++17 source code. No explanations or comments outside the code block. The code must compile and strictly follow the interactive protocol above.