You are a competitive programmer. You will be given a problem statement and must implement a solution in C++. Your output must be ONLY the C++ code wrapped in ```cpp ... ``` with no additional commentary.

Task specifics for the interactive problem "Hedgehog Graph":
- There are n independent graphs (n ≤ 10), each with 1e6 vertices (labeled 1..1e6).
- The graph is a directed pseudofunction graph: every vertex has exactly one outgoing edge, and the graph contains exactly one directed cycle of length s ≥ 3 (no loops or 2-cycles). Additionally, for any edge u -> v, v lies on that single directed cycle. Thus, after one step from any vertex, the walk remains entirely on the unique cycle.
- You can ask at most 2500 queries per graph of the form:
  ? v x
  The judge starts at vertex v, moves forward x times via the unique next edge, and returns the resulting vertex index.
  Constraints: 1 ≤ v ≤ 1e6, 1 ≤ x ≤ 5e18.
- For each graph, determine the cycle length s. Then output:
  ! s
  and read a single integer: 1 if correct (continue), or -1 if incorrect (terminate).

Important interaction protocol details:
- Always flush after every query and answer.
- The interactor is adaptive but must remain consistent with all observed answers and the problem constraints.
- Manage and respect the query budget (≤ 2500 per graph).

Key oracle behavior on a cycle vertex c:
- If c is a vertex on the cycle, then ask(c, k) returns the cycle vertex advanced by k steps modulo s.
- Specifically, ask(c, K) == c if and only if s divides K. Do NOT use K+1 here; the “multiple” test is with K itself.

Robust strategy to find s within the query budget:
1) Obtain a cycle vertex:
   - Query c = ask(v0, 1) for any v0 (e.g., v0 = 1). Since all next(v) are on the cycle, c is on the cycle.

2) Find a nonzero multiple of s via collisions:
   - Sample distinct positive integers k in [1..1_000_000] (or similar range) and query res = ask(c, k).
   - Maintain a map from returned vertex label res to the first k that produced it.
   - On seeing a collision (res seen before at k'), compute d = |k - k'|. Then d is a nonzero multiple of s.
   - Stop sampling once a collision is found or you are close to the query limit. With s ≤ 1e6, birthday paradox implies a collision in about O(sqrt(s)) ≈ 1000 samples on average (well within 2500).
   - Avoid querying the same k twice.

3) Reduce the multiple d down to s:
   - Let s_candidate = d.
   - For each prime p up to sqrt(s_candidate), while s_candidate % p == 0:
       - If ask(c, s_candidate / p) == c, then s divides s_candidate / p, so set s_candidate /= p and continue.
       - Else, stop dividing by p.
   - After trying all small primes, if s_candidate still has a prime factor > 1, attempt one more division check similarly (this is implicitly handled by the loop over primes up to sqrt at each step as s_candidate shrinks).
   - The core invariant: ask(c, K) == c if and only if s | K, so testing divisibility is done with K = s_candidate / p (not K+1).

4) Output the final s_candidate as s, flush, and read the verdict (1 or -1). On -1, exit immediately.

Implementation guidelines:
- Use 64-bit (unsigned long long / long long) for x since x ≤ 5e18.
- Use fast I/O and flush explicitly after every write related to interaction.
- Keep a strict per-graph query counter to remain under 2500, reserving a small safety margin for reduction queries.
- Use an unordered_map<int,int> or a vector<int> of size 1e6+1 for tracking first occurrence of a returned vertex label.
- Randomize k selection (uniform in [1..1e6]) and avoid repeats. You may mix in light deterministic probing if desired, but the randomized birthday approach is sufficient.
- No extra prints besides the required interactive lines and final answers.

Output formatting requirement:
- Your response to the user must contain ONLY valid, compilable C++ code wrapped in ```cpp and ```, with no explanation or extra text.