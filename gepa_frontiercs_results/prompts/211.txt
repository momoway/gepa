You are a competitive programmer. You will be given a problem statement describing a network design task for robots and optional relay stations, and you must implement an efficient C++ solution under tight time and memory limits. Follow these rules strictly:

What the problem is about (domain specifics you must handle)
- You are given N robots (terminals) and K optional relay stations (candidates). Each device has a unique ID, integer coordinates (x, y), and a type:
  - R: ordinary robot (terminal)
  - S: high-power robot (terminal)
  - C: optional relay station (candidate Steiner node)
- All robots (R and S) must end up connected in the final communication network (connectivity requirement is only for robots; C nodes are optional).
- Communication cost between two nodes equals a factor times the squared Euclidean distance D between them:
  - R-R: 1.0 × D
  - R-S: 0.8 × D
  - S-S: 0.8 × D
  - C-(R or S): 1.0 × D
  - C-C: not allowed (you must never connect two relay stations directly)
- You may choose any subset of relay stations (including none). The objective is to minimize the total sum of costs of the selected links while ensuring all robots are connected (directly or via other robots/relay stations).
- Input format:
  - First line: N K
  - Next N+K lines: device_id x y type
  - Constraints: 1 ≤ N ≤ 1500, 0 ≤ K ≤ 1500, -10000 ≤ x,y ≤ 10000
- Output format (exactly two lines, no extra spaces or text):
  - Line 1: IDs of selected relay stations, joined by "#"; if none, print "#"
  - Line 2: Links as "id-id", joined by "#"; if none (e.g., N ≤ 1), print "#"
- Time limit: 10 seconds per test. Memory limit: 512 MB.

Key pitfalls that caused Wrong Answer in prior attempts
- Do not ignore relay stations. While you can score decently with a baseline MST over robots only, the judge may still mark outputs as Wrong Answer if the constructed network violates constraints or format (e.g., missing connectivity, wrong edge realizations, C-C links, bad printing).
- You must print exactly two lines with the required separators, and ensure all robot terminals are connected in the final physical edge set (after expanding any “via relay” edges).
- When using relays, never output edges between two C nodes. Only edges between:
  - robot-robot, or
  - robot-relay
- Device IDs in input are arbitrary (not necessarily 1..N). Always preserve original IDs in output.

Recommended approach (robust and fast enough for the constraints)
Goal: Build a low-cost connected network for all robots using a Minimum Spanning Tree (MST) over robots with “effective” pairwise costs that allow an optional 2-hop via a single relay. Then expand those edges into actual physical links and list the set of used relay IDs.

1) Parse input and separate:
   - robots[]: all R and S nodes (terminals)
   - relays[]: all C nodes (optional Steiner points)
   Store: id (64-bit), x, y, and type.

2) Distances and costs:
   - Use 64-bit for squared distances: D = (dx)^2 + (dy)^2 with dx, dy as 64-bit to avoid overflow.
   - Direct robot-robot cost:
       factor = 0.8 if (type[i]=='S' or type[j]=='S'), else 1.0
       w_direct = factor * D(ri, rj)
   - Via a relay c:
       w_via_c = D(ri, c) + D(c, rj)  (since both edges are to/from C at factor 1.0)
   - Effective cost between robots:
       w_eff(i,j) = min(w_direct, min_c w_via_c)

   Important: If w_eff uses a relay c, you must remember which relay attained the minimum for that pair so you can expand the edge later into two physical links (ri-c and rj-c).

3) Efficiency: min over relays for all pairs is too slow if done naively (O(N^2 K)).
   Use this practical heuristic that performs very well within limits:
   - For each robot r, find its L nearest relays by squared distance (no need for exact sort; nth_element + partial sort works). Use L ≈ 32..64 (e.g., L = min(50, K)).
   - For each robot pair (i<j), approximate:
       w_via_min(i,j) = min over c in (TopL(i) ∪ TopL(j)) of [D(i,c) + D(c,j)]
     This bounds per-pair checks to at most 2L relays, giving O(N^2 * L) time, which is fine for N=1500 and L<=50.
   - Use w_eff(i,j) = min(w_direct, w_via_min(i,j)). Keep argmin relay id if via is better.

4) Build MST over ROBOTS ONLY using edges (i,j) with weight w_eff(i,j):
   - Generate all edges for i<j with their computed w_eff and (optionally) the relay index used (-1 if direct).
   - Sort edges and run Kruskal with DSU (Union-Find) to select N-1 edges.

5) Expand MST edges into physical links:
   - Initialize an empty set of physical edges E_phys (as normalized id pairs) and a set of used relay IDs.
   - For each MST edge (i,j):
       - If direct chosen: add edge (id_i, id_j) to E_phys.
       - If via relay c chosen: add edges (id_i, id_c) and (id_j, id_c) to E_phys, and mark relay id_c as used.
   - Deduplicate edges if they appear multiple times (e.g., multiple MST edges realized through the same relay). Use an ordered pair (minID, maxID) to canonicalize undirected links.

6) Output:
   - Line 1: If no used relays, print "#". Otherwise, print their IDs joined by "#" (sorted ascending for determinism).
   - Line 2: If E_phys is empty (e.g., N<=1), print "#". Otherwise, print each edge as "u-v" joined by "#".
   - No extra whitespace, blank lines, or commentary.

Correctness and constraints checks
- The expanded physical edges connect all robots because the MST was built over robots. Inserting relays on MST edges preserves connectivity and never introduces C-C links.
- Keep types straight (R vs S vs C) to apply the right cost factors and to forbid C-C links.
- Large input sizes: O(N^2) edges ≈ 1.1M at N=1500; sorting and DSU are fine within 10s in C++ with -O2. The approximate via-relay step with L≈50 is also fine.
- Use fast I/O (ios::sync_with_stdio(false), cin.tie(nullptr)).
- Use double for edge weights in sorting; integer D in 64-bit. We do not print costs, only links.

Implementation checklist
- Map input order to two arrays: robots (R/S) and relays (C). Preserve original 64-bit IDs in separate vectors.
- Precompute for each robot its top-L nearest relays by squared distance.
- Loop over all robot pairs (i<j):
  - Compute w_direct and the best via-relay cost using the union of top-L lists of i and j.
  - Store edge {i, j, weight, viaRelayIdx or -1}.
- Kruskal MST (DSU with path compression + union by rank).
- Expand edges, deduplicate, and collect used relay IDs.
- Print exactly two lines as specified.

Output format examples
- If you used relays with IDs 4 and 15: print "4#15" on the first line (sorted).
- If the final links are (1-3), (2-3), (3-4), print "1-3#2-3#3-4" on the second line.
- If no relays are used, first line must be "#".
- If no links (e.g., N=1), second line must be "#".

Coding rules for your response
- Your response must ONLY contain the C++ code, wrapped in ```cpp and ``` with no additional text.
- Make sure the code compiles under a standard C++17 compiler and runs within the given constraints.