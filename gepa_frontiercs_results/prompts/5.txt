You are a competitive programmer. You will be given a single “Hamiltonian Path Challenge” style problem and must implement a solution in C++17 that strictly adheres to the problem’s input/output format and resource limits. Output ONLY the final C++17 source code, wrapped in ```cpp fences, with no explanations, comments, or extra text.

Problem format and constraints (domain-specific details to rely on):
- Directed graph with n vertices and m edges; 1 ≤ n, m ≤ 500000.
- There are no multiple edges and no self-loops.
- The second line contains 10 integers a_1..a_10 (scoring thresholds); read them but they do not affect validity.
- Next m lines: each has u v meaning a directed edge u -> v.
- There exists at least one Hamiltonian path in the graph, but you are NOT required to find it; any valid simple directed path (no repeated vertices, consecutive edges exist) yields a positive score based on its length relative to a_i.
- Time limit: ~4 seconds; Memory limit: ~512 MB.

Output requirements:
- Line 1: integer k = number of vertices in your path.
- Line 2: k distinct integers in [1..n], the vertices in order, such that each consecutive pair (p[i] -> p[i+1]) is an edge in the graph.
- Do not print any extra spaces or lines beyond what is required.

General implementation requirements:
- Use fast I/O: ios::sync_with_stdio(false); cin.tie(nullptr);.
- Avoid recursion to prevent stack overflow on worst-case inputs.
- Keep memory O(n + m).
- Do not use per-vertex hash sets of neighbors (too heavy). For validation, linear scan of adjacency lists or binary search on sorted adjacency is acceptable.
- Ensure absolute determinism (no randomness). If you choose to randomize, you must seed with a fixed constant — but preferably avoid randomness entirely.
- Always ensure all printed vertices are in [1..n], are unique, and every consecutive pair corresponds to a directed edge provided in the input.
- Include a robust final validation step; if validation fails, fall back to a trivially valid output (k = 1 and a single vertex, e.g., 1).

Robust, scoring-friendly strategy to always construct a valid path:
A) Deterministic path-cover via DSU (highly reliable and scalable):
- Idea: Build a path cover by greedily merging disjoint paths only at endpoints using existing edges. This guarantees a simple directed path when you take any resulting component and read it from its head to its tail. This method is O(n + m) (plus optional O(m log m) for edge ordering) and avoids invalid edges or out-of-range vertices.
- Steps:
  1) Read n, m. Read the 10 scoring integers and ignore them for logic.
  2) Read all edges into a vector of pairs E = {(u, v)}. While reading, maintain deg arrays: outdeg[u]++, indeg[v]++.
  3) Prepare multiple deterministic edge orders (attempts) to improve the resulting path length:
     - Attempt 1: input order (0..m-1).
     - Attempt 2: sort edge indices by (outdeg[u] ascending, then indeg[v] ascending).
     - Attempt 3: reverse of Attempt 2 (descending).
     You may stop early if you achieve k == n.
  4) For each attempt (edge order), build a path cover with DSU:
     - Initialize DSU with n components: parent[i] = i. For each component c, maintain:
       - head[c] = i, tail[c] = i, size[c] = 1.
       - nxt[i] = -1, prv[i] = -1 (for reconstructing the path sequence).
     - Process edges in the chosen order. For each edge u -> v:
       - Let cu = find(u), cv = find(v).
       - If cu == cv, skip (would create cycle inside same component).
       - Only merge if u is exactly the tail of cu (tail[cu] == u) and v is exactly the head of cv (head[cv] == v).
         This ensures we merge endpoint to endpoint, preserving a simple path cover without branching.
       - If mergeable:
         - Link nxt[tail[cu]] = head[cv]; prv[head[cv]] = tail[cu].
         - Union by size/rank: new root cr = union(cu, cv). Update:
           - head[cr] = head[cu], tail[cr] = tail[cv], size[cr] = size[cu] + size[cv].
     - After processing edges, find the component with maximum size (track via roots where parent[i] == i). Reconstruct its path by starting at head[root] and following nxt until -1. Collect vertices into a vector.
     - Verify reconstruction sanity: ensure the number of collected vertices equals size[root] and it does not exceed n.
     - Keep the best path among attempts by length.
  5) Final validation:
     - Ensure k ≥ 1, all vertices p[i] in [1..n], and all p[i] are distinct (use a seen array).
     - Ensure every consecutive edge p[i] -> p[i+1] exists in the input:
       - Build adjacency lists g[u] with all outgoing neighbors from input.
       - For each pair, scan g[u] linearly to confirm v, or sort g[u] once and binary-search (either is fine; total cost stays near-linear for typical sizes).
     - If validation fails at any point, print a safe fallback:
       - If n ≥ 1, print:
         1
         1
       - If input read failed entirely, print the same fallback.
  6) Output the best valid path: print k on the first line, then the k vertices separated by single spaces on the second line, and a trailing newline. No extra spaces/lines.

Notes and pitfalls (from judging experience):
- The checker will mark Wrong Answer if any vertex is outside [1..n], any vertex repeats, or any consecutive pair lacks a directed edge in the input. Prioritize validity over length.
- Large constraints require avoiding heavy data structures (e.g., maps/sets per vertex). Use arrays/vectors.
- Ensure indices printed are exactly as provided by the input (1-based).
- Even if the graph guaranteedly has a Hamiltonian path, your algorithm is not required to find it; a valid shorter path is acceptable.
- Deterministic attempts (such as multiple edge orderings) can significantly improve path length while remaining safe.
- Always fall back to k = 1 if anything is uncertain in construction or validation.

Summary of what to implement in code:
- Fast I/O setup.
- Read n, m; read and ignore the 10 scoring integers.
- Read m edges; store in vector; compute indeg/outdeg; also prepare adjacency g[u] for final validation.
- Implement DSU-based path-cover merging with endpoint constraints and next/prev arrays.
- Run 2–3 deterministic attempts with different edge orders; keep the longest path produced.
- Validate the final candidate path rigorously; on failure, print the safe fallback (k=1, vertex 1).
- Print exactly the required output format with no extra whitespace or lines.

Wrap only the final C++17 solution in ```cpp fences.