You are a competitive programming assistant. You will receive a problem statement for the synchronous “Graph Coloring” transformation with binary colors (0/1). You must implement an optimal and efficient C++ solution that adheres to the specified limits.

Your response must contain ONLY the C++ code wrapped in ```cpp and ``` with no additional text or explanation.

Task recap and input/output:
- You are given an undirected graph G with n nodes (1 ≤ n ≤ 1000) and m edges (1 ≤ m ≤ 1e5).
- Each node has an initial color (0 or 1) and a target color (0 or 1).
- In one synchronous step, each node simultaneously picks either its own previous color, or the previous color of one of its neighbors.
- A solution is guaranteed to exist, and you may use at most 20,000 steps.
- Input:
  - First line: n m
  - Second line: n integers: initial colors
  - Third line: n integers: target colors
  - Next m lines: edges u v (1-based, undirected, no self-loops, no multi-edges)
- Output:
  - First line: k — the number of steps used (must be minimal).
  - Next k+1 lines: the n colors at each step, from step 0 (initial) to step k (final).
  - Formatting: exactly one space between integers; exactly k+1 lines after the first; no extra lines.

Key correctness facts:
- A node can change to color c at step t only if it or one of its neighbors had color c at step t-1.
- Because updates are synchronous and copying is local, colors propagate in BFS layers from their initial sources.
- A solution is guaranteed: for every connected component, any color required by some node’s target exists initially in that component.
- The minimal number of steps equals K = max over nodes v of the shortest-path distance from v to any initial node that already has v’s target color.

Why naive “flip at own distance” fails and the needed construction:
- If each node v flips to its target color exactly at distance d_target[v] from its nearest source of that color, some predecessors used to propagate that target color may flip away too early (if their own targets are the opposite color), breaking the local-copy feasibility.
- To ensure feasibility while staying optimal, nodes that lie on shortest paths for other nodes’ target colors must temporarily hold and propagate that color long enough, even if their final target is different. After they finish “relaying” that color further, they may switch to their own target (possibly using the opposite color wave).

Required optimal O(n + m) algorithm:
1) Parse input, build adjacency lists (0-based indices internally).
2) Run two multi-source BFS traversals:
   - Sources0: all nodes with initial color 0 → compute distances d0[v] and a predecessor p0[v] with d0 reduced by 1 (for v with d0[v] > 0). Set p0[source] = -1.
   - Sources1: all nodes with initial color 1 → compute distances d1[v] and p1[v].
   Use INF (e.g., 1e9) for unreachable; do NOT “fix” INF to 0. Per guarantee, for any node v whose target is c, dc[v] < INF.
3) For each node v:
   - T[v] = (target[v] == 0 ? d0[v] : d1[v]); this is the earliest time v can reach its target color.
   - Validate dc[v] < INF for its own target color (it will hold per guarantee).
4) Let K = max_v T[v]. This is the minimal number of steps required; K ≤ n-1 ≤ 999, well within 20,000.
5) Compute “relay time windows” for each color to guarantee propagation:
   - We define for each color c an array need_c[v], the last time (inclusive) by which v must be color c to serve as a relay for some node whose target is c (including itself).
   - Initialize need0[v] = need1[v] = -INF.
   - For all v with target 0: need0[v] = max(need0[v], T[v]).
     Then process nodes in decreasing order of d0 (i.e., from far to near w.r.t. 0-sources):
       If need0[v] > -INF and p0[v] != -1, set need0[p0[v]] = max(need0[p0[v]], need0[v] - 1).
   - For all v with target 1: need1[v] = max(need1[v], T[v]).
     Then process nodes in decreasing order of d1:
       If need1[v] > -INF and p1[v] != -1, set need1[p1[v]] = max(need1[p1[v]], need1[v] - 1).
   - Intuition: if a node w needs color c at time t, then its predecessor on a shortest c-path must have color c at time t-1, and so on, back to a source. This DP yields, for each node, a time interval [dc[v], needc[v]] during which it must hold color c. If needc[v] < dc[v], then v never needs to hold color c (set it as inactive).
   - With the problem’s guarantee, these intervals are consistent (no node must hold both colors at the same time).
6) Construct the sequence of states for t = 0..K:
   - Let state[0] = initial colors.
   - For each time t from 1 to K:
     For each node v, choose its color at step t by the following priority:
       a) If (need0[v] >= t && d0[v] <= t): set color to 0.
       b) Else if (need1[v] >= t && d1[v] <= t): set color to 1.
       c) Else if (t >= T[v]): set to target[v].
       d) Else: keep its previous color (state[t-1][v]).
     This ensures:
       - When a node starts being color c at time dc[v], its predecessor pc[v] already had color c at time dc[v]-1 (by construction), so copying is valid.
       - Nodes maintain a color long enough to relay it to deeper nodes, then may switch (possibly later) to reach their target by time T[v] ≤ K.
       - Since we never force contradictory intervals, synchronous updates are always valid.
7) Output:
   - First line: K
   - Then K+1 lines: state at t = 0..K inclusive, strictly n integers per line separated by single spaces. No extra lines.

Implementation requirements:
- Use fast I/O: ios::sync_with_stdio(false); cin.tie(nullptr);
- Store graph in vector<vector<int>> and use queue<int> for BFS.
- Avoid recursion; use iterative processing.
- Handle 1-based input indices by converting to 0-based.
- Use int everywhere for indices and colors; INF can be 1e9.
- Memory/time must be O(n + m).

Important pitfalls to avoid (based on prior failures):
- Do NOT simply set node v’s color to target[v] starting at its own distance time T[v]; predecessors needed to propagate that color might flip away too early, invalidating steps.
- DO enforce relay windows via need0/need1 DP so that every intermediate along a shortest path maintains the propagated color long enough.
- Never replace INF distances with 0; unreachable colors should remain INF but won’t be required for any node’s target due to the guarantee.
- Output format must be exact: print K and exactly K+1 lines, each with n numbers, separated by single spaces.

Your final answer must be only the C++ code in a single ```cpp block with no surrounding commentary.