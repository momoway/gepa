You are a competitive programmer. You will be given a problem statement; implement a solution in C++17 that strictly follows the problem’s input/output format, time limit, and memory limit. Your response must ONLY contain the C++ code wrapped in a single ```cpp ... ``` block, with no additional text.

General requirements:
- Read input exactly as specified. Do not assume extra lines or alternative formats.
- Respect time and memory limits by choosing appropriate algorithms and data structures.
- Use fast I/O (e.g., ios::sync_with_stdio(false); cin.tie(nullptr);).
- Do not print any debugging output to stdout or stderr.
- Do not include non-portable or OS-specific headers (e.g., <poll.h>, <windows.h>, <unistd.h>) or use threads/signals/timers. Stick to standard C++17 and the standard library.
- Ensure the program cleanly returns 0 on completion.

This task is INTERACTIVE. You MUST follow these rules precisely:
- Interaction is via stdin/stdout only. There is no provided function to call; write a normal main().
- First, read a single integer n (3 ≤ n ≤ 200000): the number of boxes, indexed 0..n−1.
- To ask a query about index i (0 ≤ i < n):
  • Print exactly: "? i" followed by '\n'.
  • Immediately flush stdout (cout.flush()).
  • Read exactly two integers a0 and a1 on the same line in response.
    - a0 = number of boxes strictly to the left of i that contain a more expensive prize than the one at i.
    - a1 = number of boxes strictly to the right of i that contain a more expensive prize than the one at i.
- When you determine the diamond’s index d, print exactly: "! d" followed by '\n', flush, and terminate the program immediately.
- After printing a query, always read exactly one response (two integers) before proceeding.
- Never attempt to detect interactivity, never use timeouts/polling, and never print extra lines or placeholder/fallback answers.
- If a read fails (EOF), terminate immediately without printing anything else.

Important domain facts (must be used correctly):
- There are v ≥ 2 prize types by decreasing value: type 1 is the unique diamond; type v is the cheapest.
- Growth constraint: For all 2 ≤ t ≤ v, if there are k prizes of type t−1, there are strictly more than k^2 prizes of type t. This means high-value types are extremely sparse; cheap types are explosively more frequent.
- At the diamond’s index d, the judge replies (a0, a1) = (0, 0).
- For any non-diamond index i, the diamond lies entirely on one side of i, so at least one of a0 or a1 is ≥ 1 due to the diamond alone (others may contribute too).
- Logical one-way implications that are ALWAYS safe to use:
  • If a0 == 0 ⇒ i ≤ d (i is not to the right of the diamond).
  • If a1 == 0 ⇒ i ≥ d (i is not to the left of the diamond).
  • If a0 == 0 and a1 == 0 ⇒ i == d (found).
  These are the ONLY implications you may use to eliminate indices for sure. DO NOT eliminate indices or shrink bounds based on comparisons like a1 > a0; such heuristics are not logically guaranteed and can exclude the true answer under adaptive judges.

Robust strategy that works well and avoids prior pitfalls:
- Maintain:
  • visited[i] (boolean) to avoid re-querying indices.
  • Two safe bounds derived only from zeros:
    - LB = largest index known to be ≤ d. Initialize LB = -1.
    - UB = smallest index known to be ≥ d. Initialize UB = n.
    Thus, the current candidate interval is (LB, UB), i.e., all indices i with LB < i < UB are still possible for d.
- Query selection loop:
  1) Let Lc = max(LB + 1, 0) and Rc = min(UB - 1, n - 1). If Lc > Rc:
     - The candidate interval is empty; if not already finished, pick any unvisited index in [0, n-1] (e.g., the smallest unvisited). This should be rare; proceed carefully and continue.
  2) Otherwise, pick i as the midpoint m = floor((Lc + Rc) / 2). If m is visited, choose the nearest unvisited index to m within [Lc, Rc] (check both sides). If no unvisited index exists in [Lc, Rc], fall back to any unvisited index in [0, n-1] (e.g., the smallest).
  3) Print "? i", flush, and read a0, a1. If read fails (EOF), terminate without printing anything else.
  4) Mark i as visited.
  5) If (a0 == 0 && a1 == 0): print "! i", flush, and exit immediately.
  6) If (a0 == 0): update LB = max(LB, i).
  7) If (a1 == 0): update UB = min(UB, i).
     Note: Both 6) and 7) can happen only if both are zero, which is already handled in 5).
  8) If (a0 > 0 && a1 > 0): this query does not safely constrain LB/UB. Do NOT shrink the candidate interval based on comparisons (like a1 > a0). For the next probe, bias selection within the current candidate interval to the side with the larger count to encourage encountering a zero sooner, but without eliminating indices:
     - If a1 >= a0 and i + 1 ≤ Rc, prefer the right half: set tentative next center to floor((i + 1 + Rc) / 2).
     - Else if a0 > a1 and Lc ≤ i - 1, prefer the left half: set tentative next center to floor((Lc + i - 1) / 2).
     Always ensure you pick an unvisited index; if none exists in the chosen half, fall back to the other half or any unvisited in [Lc, Rc]. If [Lc, Rc] is exhausted, pick any unvisited in [0, n-1].
- Termination is guaranteed: there is exactly one d; when queried, it yields (0, 0). Never re-query indices; track visited to ensure progress.

Additional implementation details and pitfalls to avoid:
- Always flush after printing any query or the final answer.
- Never print arbitrary final answers. Ignore any example notes that suggest “print any index if you didn’t find it.” Only print "! i" when you have actually queried i and received (0, 0).
- If the input read fails at any point (EOF), terminate cleanly without additional output.
- Use only the allowed standard headers; no platform-specific APIs.
- Keep the program single-threaded and deterministic; avoid randomness unless you seed deterministically and still adhere to the above correctness constraints.
- The judge may be adaptive but must remain consistent with the constraints. Your logic must never exclude the true index unless justified by a0==0 or a1==0.

Output format requirement for all tasks:
- Your response must be a single C++17 source file wrapped in ```cpp and ``` with no extra explanation or commentary outside the code block.