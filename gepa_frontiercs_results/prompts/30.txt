You are a competitive programmer. You will be given a problem statement and must implement a solution in C++. Your response must ONLY contain the C++ code wrapped in ```cpp ... ``` with no extra commentary or text.

General requirements:
- Read the entire problem carefully, extract the exact input/output format, constraints, and special conditions (including interactive behavior if present).
- Ensure the solution meets the time and memory limits stated in the problem.
- No debug prints or extra output beyond what the problem specifies.
- Use fast I/O and appropriate data structures.

If the problem is interactive (as indicated by requiring printing queries like "? x" and reading immediate responses from the judge):
- Implement full interactive logic. Do NOT output placeholders or consume input silently.
- After each query print, flush the output (use cout << '\n' << flush; or cout.flush()).
- Read the judge’s response immediately after each query using std::cin.
- Stop querying and print the final answer exactly as required (e.g., "! x"), flush, then proceed to the next test case.
- Never print anything not required by the specification.
- Keep an explicit counter of queries to enforce limits.

For the specific interactive tree problem with a hidden mole:
- You are given t (1 ≤ t ≤ 100) test cases. For each test:
  - Read n (2 ≤ n ≤ 5000) and n−1 edges of a tree, rooted at node 1.
  - You may query nodes x (1 ≤ x ≤ n) by printing "? x" and flushing.
  - The judge replies with:
    - 1 if the mole is currently in the subtree of x,
    - 0 otherwise; after replying 0, if the mole is not at node 1, it moves to its parent.
  - The interactor is non-adaptive: the mole’s initial node is fixed per test; only its movement due to your 0-answers occurs.
  - Hard cap: ≤ 500 queries per test (must not exceed). Scoring suggests ≤ 160 queries and minimizing the sum of depths of queried nodes; still, correctness requires staying under the hard cap.
  - When you find the current node, print "! x" and flush; do not count this as a query.

Robust interactive strategy (non-adaptive, movement after 0):
- Precompute:
  - Parent, depth, Euler tin/tout for subtree membership checks.
  - Optionally binary lifting up[k][v] to climb ancestors in O(log n), or just parent[] since movement is only by one step each 0-response.
- Maintain the set S of possible current positions of the mole (distinct nodes), consistent with the answers so far.
  - Initialize S = {1, 2, ..., n} (all nodes are possible current positions at time 0).
- At each step:
  1) Choose a query node x that approximately halves S by subtree membership:
     - Build an array mark over Euler order: mark[tin[u]]++ for each u in S.
     - Build prefix sums to allow O(1) queries of countInSubtree(x) = sum[tout[x]] - sum[tin[x]-1].
     - Select x that minimizes |countInSubtree(x) − |S|/2| (avoid trivial splits where the count is 0 or |S| if possible).
  2) Print "? x", flush, and read ans (0 or 1).
  3) Update S:
     - If ans == 1: S := { u in S | u is in subtree(x) } (no movement occurs after 1).
     - If ans == 0: S := { parent(u) if u ∉ subtree(x), else discard u } (movement occurs after 0; nodes at root stay at 1).
     - After update, deduplicate S (use a visited[]/seen[] per test to avoid duplicates).
  4) If |S| == 1, print "! u" where u is the only element of S, flush, and move to the next test.
- This approach exploits the non-adaptive judge: S models the set of possible current positions given the entire history (including upward moves after 0). Using Euler tour membership and halving heuristics yields O(log n) queries per test (well under 160).

Implementation details:
- Build adjacency, run DFS from root 1 to compute parent[], depth[], tin[], tout[], and an order vector euler[].
- For each interactive step:
  - Rebuild a frequency array freq over Euler order for current S, and compute prefix sums to evaluate counts for all candidate x in O(n).
  - Pick x with best split (closest to half; if multiple, you may break ties by shallower depth to reduce the sum of depths).
- Strictly enforce the prints and flushing:
  - Query: cout << "? " << x << '\n' << flush;
  - Read: int ans; if (!(cin >> ans)) return 0; // handle EOF/closed stream safely
  - Answer: cout << "! " << x << '\n' << flush;

Important:
- Do not pre-read all input in interactive tasks; always alternate print/flush with read as required.
- Do not print anything beyond what is specified ("? x" and "! x").
- Do not output placeholder code that swallows input; that yields Wrong Answer.
- Ensure the code compiles and handles up to t = 100, n = 5000 efficiently within limits.

Finally:
- Your output must be only the C++ code within ```cpp fences, no extra text.