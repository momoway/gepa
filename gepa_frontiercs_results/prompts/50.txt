You are a competitive programmer. Implement a high-quality heuristic solver in C++ for a weighted set cover variant with strict feasibility requirements and a scoring judge.

Task summary and input format (from judge and examples):
- Time Limit: 10 seconds (hard). Leave headroom; stop heuristic loops around 9.4–9.6s.
- Memory Limit: 1024 MB.
- Input:
  - First line: two integers n and m
    - 1 <= n <= 400 (elements)
    - 1 <= m <= 4000 (sets)
  - Second line: m integers, the i-th is the cost c_i (64-bit)
  - Then for each element i from 1 to n:
    - A line starts with integer k_i (the number of sets that contain element i)
    - Followed by k_i integers a_j (1-based IDs of sets that contain element i)
- Goal:
  - Choose a subset S of the m sets so that every element 1..n is contained in at least one chosen set.
  - Minimize total cost sum of chosen sets.
  - This is a scoring problem: lower cost yields a better score. Any uncovered element results in Wrong Answer regardless of score.

Output format (strict):
- First line: integer |S|, the number of chosen sets.
- Second line: exactly |S| space-separated set IDs (1-based), in any order.
- Do not print any extra text, logs, or blank lines beyond these two lines.

Critical constraints and pitfalls (adhere strictly to avoid WA):
- Ensure every element 1..n is covered at least once before printing. Re-verify after all pruning/local search.
- Use 1-based IDs in output, no duplicates, all IDs within [1..m].
- If an element has k_i = 0 (no covering set), a feasible cover is impossible; in that rare case, output "0" and an empty second line.
- Use fast I/O (ios::sync_with_stdio(false); cin.tie(nullptr);).
- Use 64-bit for costs and sums (long long).
- Respect the 10s limit and stop all heavy loops early (e.g., 9.5s).
- Never update cover counters when “adding” a set that is already selected, nor when “removing” a set that is not selected. Double-counting coverCnt followed by pruning can silently break feasibility.
- After any construction, pruning, or local search move, keep the coverCnt array consistent with usedSet and verify that removing a set is legal only if all its elements have coverCnt >= 2 before removal.
- After a last-chance repair step, do NOT prune again unless you will re-repair immediately; always end with a verified feasible solution.
- Avoid outputting duplicates: ensure the final chosen set IDs are deduplicated and consistent with usedSet.

Recommended approach (robust and strong under constraints):
- Data structures:
  - For each set s: vector<int> elems[s] listing covered elements (build from element-side input).
  - For each element e: vector<int> setsOf[e] listing sets that contain it (from input).
  - Maintain coverCnt[e] (int) = how many currently selected sets cover e.
  - Maintain usedSet[s] (bool/char) = whether set s is picked.
  - Optionally maintain a membership table mem[s][e] as an unsigned char (0/1) to accelerate “does s cover e?” checks. With n<=400 and m<=4000, m*n≈1.6M bytes is OK.
  - Maintain a coveredCount integer.

- Construction phase (guarantee feasibility first, then quality):
  1) Forced picks (unit propagation):
     - For any element e with exactly one set s in setsOf[e], select s (if not already chosen). Repeat until no changes. Update coverCnt and coveredCount accordingly.
  2) Greedy randomized:
     - While coveredCount < n:
       - For each unselected set s, compute gain = number of currently uncovered elements it would newly cover.
       - Select a set with best ratio cost/gain (lower is better). To diversify, select uniformly from the best top-K (e.g., K in [6..16], use K≈12).
       - Add set only if usedSet[s] is false; then increment coverCnt for its elements and update coveredCount and any cached gains for affected sets incrementally.
     - Fallback safety: if any uncovered element remains due to corner cases, add the cheapest set among setsOf[e] for that element. Only update coverCnt when transitioning a set from unused to used.
  3) Post-construction repair:
     - Final sweep: for any element with coverCnt[e] == 0, add the cheapest set among setsOf[e] (only if not already used). If all covering sets are already used (rare), do NOT increment coverCnt again. This step must never double-count coverCnt.

- Pruning:
  - After constructing a feasible solution, iteratively remove any redundant set s where all its elements have coverCnt[e] >= 2 (i.e., removing s keeps coverage). Process sets in descending cost order to maximize savings. When removing, only decrement coverCnt if usedSet[s] was true; never go below zero.

- Local search improvements (time-bounded; repeat until time budget exhausted or no progress):
  - Maintain addSet(s) and removeSet(s) functions that strictly toggle usedSet and consistently update coverCnt and totalCost; they must be no-ops if the state wouldn’t change.
  - 1-for-1 replacement:
    - For a selected set A, compute U = elements uniquely covered by A (coverCnt[e] == 1).
    - Try to find an unselected set B with cost(B) < cost(A) that covers all elements in U (U ⊆ elems[B]). If found, add B, remove A, then prune and continue.
  - 1-for-2 replacement:
    - For a selected set A with U as above, try to find two unselected sets B, C such that cost(B)+cost(C) < cost(A) and U ⊆ elems[B] ∪ elems[C].
    - Build a candidate pool from sets covering any e in U; rank by cost/gain over U; try combinations from a small top-K (e.g., K≤50) to stay fast.
  - Optional 2-for-1 replacement:
    - For two selected expensive sets whose union of uniquely covered elements can be covered by one cheaper unselected set; only if time permits.
  - After any successful replacement, run pruning; ensure coverCnt consistency throughout.
  - Stop local search when no improvement or time is near the limit.

- Multi-start + time management:
  - Keep the current best feasible solution (by total cost) found so far.
  - Run multiple randomized greedy constructions (vary RNG seed and/or TopK) followed by prune + local search within the time budget.
  - Use a steady clock. Aim to stop iterations well before 10s to be safe (e.g., 9.5s total).

- Robust feasibility and correctness checks (must be done before output):
  - Verify that every element e has coverCnt[e] > 0.
  - Verify that usedSet[s] true corresponds exactly to the IDs collected for output; deduplicate if collecting via a vector.
  - Verify all printed set IDs are within [1..m] and unique.
  - If at any point infeasibility is detected late (should be rare), perform a repair pass: for each uncovered element add the cheapest covering set (only if not used), update coverCnt, then optionally prune cautiously and re-verify. If still infeasible (e.g., k_i=0), output 0 and an empty second line.

Implementation requirements:
- C++17 or newer.
- Fast I/O.
- Use only standard library (no Boost).
- Seed RNG via high-resolution clock.
- Avoid heavy per-iteration sorting where possible; use nth_element + small K windows for candidate lists.
- Memory: mem matrix of size m x n as unsigned char is acceptable under 1024 MB; do not use fixed-size std::bitset. Prefer vectors/arrays.

Your output must ONLY contain the C++ code (no explanations), exactly as required by the judge:
- Wrap the entire solution in:
  // ... your code ...
- Print exactly two lines: count and the list.
- No extra logs or blank lines.

Important bug avoidance (observed pitfalls that cause WA despite a decent score):
- Never increment coverCnt for a set that is already selected (and never decrement for a set not selected). Especially in any “final safety” or repair step, ensure you do not “re-add” an already used set or double-count coverage; otherwise pruning may wrongly remove necessary sets and produce an uncovered output.
- After pruning, re-verify feasibility; if not feasible, immediately repair.