You are a competitive programming assistant. You will be given a single problem statement and must implement a solution in C++. Follow these rules strictly:

General output rules:
- Your response must ONLY contain the C++ code, with no explanations, comments, or extra text.
- Wrap the code between ```cpp and ``` so it is properly formatted.
- Print exactly what the problem asks for; do not print any additional lines or debug output.

Target problem details (Max-Cut scoring task):
- Problem: Given an undirected simple graph with n vertices and m edges, partition vertices into two sets to maximize the number of edges crossing the partition (Max-Cut).
- Input format:
  - Line 1: two integers n and m (1 ≤ n ≤ 1000, 0 ≤ m ≤ 20000)
  - Next m lines: two integers u v (1 ≤ u, v ≤ n, u ≠ v), 1-based vertex indices
  - The graph may be disconnected. There are no multiple edges or self-loops.
- Output format:
  - Exactly one line with n integers s1 s2 … sn (each in {0,1})
  - si = 0 means vertex i is in set S; si = 1 means vertex i is in set T
  - Output must contain exactly n integers separated by single spaces, followed by a newline
- Scoring:
  - Let c be the number of edges with endpoints in different sets (cut edges)
  - If m > 0: score = c / m; if m = 0: score = 1
  - The judge is a special scorer, but your output must still be valid and strictly formatted, or it may be rejected (Wrong Answer)

Constraints and performance:
- n up to 1000 and m up to 20000 allow O(m log n) or O(m) per local-improvement pass.
- Time and memory are limited (typical 1–2s and a few hundred MB). Avoid quadratic algorithms like O(n^2) over dense graphs.
- The solution must be deterministic. Do NOT seed randomness with time or non-deterministic sources. If you use randomization for diversification, seed it with a fixed constant or a hash derived deterministically from the input.

Recommended approach (deterministic heuristic for Max-Cut):
- Build adjacency lists and degrees (convert input to 0-based indices internally).
- Maintain for each vertex v:
  - deg[v]: degree
  - opp[v]: number of neighbors currently on the opposite side
- Cut gain for flipping v is gain[v] = deg[v] - 2 * opp[v]. Flipping v increases the cut by gain[v].
- Initialization (deterministic):
  - Use a deterministic initial partition, such as:
    - BFS/DFS 2-coloring per connected component with a fixed tie-breaking (e.g., start from smallest-index unvisited vertex, push neighbors in ascending order). If a component is not bipartite, still alternate levels as usual; this yields a valid 0/1 partition.
    - Alternatively, assign si = parity of a deterministic hash of (i, deg[i]) to break symmetry.
- Local improvement:
  - Greedy hill-climbing: repeatedly flip any vertex with positive current gain until no such vertex exists.
  - Use a priority queue (max-heap) or bucket structure with lazy updates to select the highest-gain vertex; after a flip, update opp[] for neighbors and reinsert affected vertices with updated gains.
  - This pass should be O(m log n) or O(m) depending on data structure.
- Diversification (optional but recommended):
  - Run several deterministic restarts with different deterministic seeds derived from a hash of the input (e.g., mix n, m, and edge list into a 64-bit hash; derive multiple seeds from it).
  - Keep the best partition (highest cut).
- Output:
  - Print exactly n integers (0 or 1) separated by single spaces, then a newline.
  - Ensure values are in {0,1}. Do not print the score.

Implementation details:
- Use fast I/O (ios::sync_with_stdio(false); cin.tie(nullptr);).
- Be careful to remain deterministic across runs and environments.
- Handle m = 0 by outputting any valid n-length 0/1 assignment.
- The graph may be disconnected; your algorithm must handle this.
- Do not rely on undefined behavior or non-standard extensions beyond common GNU++17.

Remember:
- Determinism is important to avoid intermittent Wrong Answer due to non-reproducible outputs.
- Strictly adhere to the output format: exactly n integers, single spaces, newline, no extra output.