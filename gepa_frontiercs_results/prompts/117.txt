You are a competitive programmer. Implement an INTERACTIVE C++17 solution for the problem “Line” (recovering N integer lines from sum-of-distances). Your program must strictly follow the interactive protocol, be numerically robust, and be query‑efficient (≤ 10000 hard cap; aim ≤ 402 when input sizes permit). Do not print any extraneous output (no debug, no extra spaces/lines).

Problem summary and constraints (domain-specific facts you must rely on):
- Territory: axis-aligned square [-1e12, 1e12] × [-1e12, 1e12].
- Unknown lines: y = a_i * x + b_i, with a_i, b_i ∈ [-10000, 10000], all integers.
- No two lines are parallel (slopes a_i are pairwise distinct).
- 1 ≤ N ≤ 100.
- Interactor query: print “? x y”, flush; interactor returns the sum of Euclidean distances from (x, y) to all N lines (floating-point).
- Final answer (exactly once): “! a_1 a_2 ... a_n b_1 b_2 ... b_n”, newline, flush. Output order is arbitrary.
- Always keep |x|, |y| ≤ 1e12. Use 64-bit integers (long long) for indices/coordinates; use long double for all floating computations. Print x and y with fixed and 15 decimals.
- Scoring: Q_max = 10000, Q_min = 402. If Q ≤ Q_min, full score; else linear penalty up to Q_max; if Q > Q_max, score 0.

Crucial geometric-algebraic identities you must use:
- For any fixed integer X, define c_i = a_i*X + b_i. For |X| > 20000, all c_i are pairwise distinct INTEGERS (since a_i, b_i ∈ Z and slopes are distinct).
- Distance from (X, y) to line i: |y - c_i| / sqrt(a_i^2 + 1). Let w(a) = 1 / sqrt(a^2 + 1).
- For any integer t, define:
    s_X(t) = ( g_X(t + 0.75) - g_X(t + 0.25) ) / 0.5
  where g_X(y) is the interactor’s response at (X, y).
  Then s_X(t) = Σ_i w(a_i) * sgn((t + 0.5) − c_i). This is the exact piecewise-constant slope on (t+0.25, t+0.75), never hitting kinks at integer c_i.
  Across a kink (when passing an integer c_i upward in y), s_X jumps by +2*w(a_i).

High-level strategy (query-efficient and robust):
1) Fix a single integer X0 with |X0| > 20000, e.g., X0 = 30011 (fits within limits).
   - For each integer slope k ∈ [-10000, 10000], any line with slope a=k has c in a small “window” Ik = [k*X0 − B, k*X0 + B].
   - Choose B = 11000. With X0 = 30011, the windows Ik are pairwise disjoint and far from the “index boundaries” between slopes.
2) Use s_X(t) values at carefully chosen integer t near index boundaries to:
   - Identify exactly which integer slopes a_i are present (group testing in index space).
   - For each detected slope a, locate its unique integer c = a*X0 + b inside its window Ik via a robust integer binary search based solely on slope jumps (no raw g-values).
3) Compute b = c − a*X0 for each recovered line; output all pairs in any order.

Core construction details:

A) Query and caches
- Implement:
  - queryXY(ld x, ld y) -> ld: prints “? x y” with fixed << setprecision(15), flushes, then reads the floating response as long double. Increment a global query counter. On input failure (EOF), exit cleanly without printing extra text.
  - slopeS_X(ll t) -> ld: returns 2 * ( g(X0, t + 0.75) − g(X0, t + 0.25) ). Cache by integer t (unordered_map<ll, ld>) so each t costs at most two g-queries once. Never sample at integer y.
  - boundarySlope(int k) -> ld: slope at the boundary between slope indices k and k+1. Compute:
        tb = floor( (k + 0.5) * X0 − 0.5 )
        return slopeS_X(tb)
    Cache boundarySlope(k) (unordered_map<int, ld>).
- Helper: w_of(int a) = 1 / sqrtl((ld)a*a + 1). Monotone in |a|; range ≈ [1e-4, 1].

B) Numerics and tolerances
- Use long double throughout for g and slopes.
- eps_slope / eps_block: absolute thresholds to distinguish zero segments and detect jumps. Each jump magnitude is 2*w(a) with w(a) ≥ ~1e-4, so jumps ≥ 2e-4. With 15-decimal prints, numerical noise is small; set:
  - eps_block ≈ 1e-10 (5e-11 to 5e-10 acceptable).
  - eps_leaf ≈ 2e-10 for leaf verification.
  - eps_jump ≈ 5e-10 to test whether a jump has occurred.
- Always query at y = integer t + 0.25 and t + 0.75. Never hit y as an integer.

C) Index windows and safe boundaries
- B = 11000, X0 = 30011 ⇒ windows Ik = [k*X0 − B, k*X0 + B] disjoint.
- Boundary between k and k+1: y = (k + 0.5)*X0. With tb = floor((k + 0.5)*X0 − 0.5), the evaluation interval (tb+0.25, tb+0.75) is far (≥ X0/2 − B ≈ 4011.5) from any Ik, so s_X(tb) is uncontaminated by kinks.

D) Detect present slopes a_i via boundary recursion (group testing)
- KMIN = −10000, KMAX = 10000.
- Precompute s_baseL = boundarySlope(KMIN − 1), s_baseR = boundarySlope(KMAX).
- For any inclusive integer block [L..R]:
    J(L,R) = boundarySlope(R) − boundarySlope(L − 1)
    WT(L,R) = J/2  // sum of w(a) over present slopes a ∈ [L..R]
- Recursive solver:
    solve(L, R, sL, sR):
      WT = (sR − sL)/2
      if |WT| ≤ eps_block: return
      if L == R:
         // Leaf with nonzero weight => slope present
         // Sanity: check |WT − w_of(L)| ≤ eps_leaf (preferred). If within threshold, accept slope L.
         // If not within eps_leaf but |WT| is clearly > 0, treat with caution; see fallback below.
         record L
         return
      M = floor((L + R)/2)
      sM = boundarySlope(M)
      solve(L, M, sL, sM)
      solve(M + 1, R, sM, sR)
- Optional performance improvement if comfortable: multi-way splitting (e.g., P = 16..32) per level by precomputing P − 1 boundarySlope values inside [L..R], recurse only into subblocks with nonzero WT. This reduces total boundary queries and helps reach ≤ 402 queries when N is small/moderate. Binary recursion alone remains under 10000.

E) Robustly ensure exactly N slopes are recovered
- After recursion, let S be the set of detected slopes, with their measured leaf weights WT(L,L).
- If |S| == N and Σ_a∈S w_of(a) ≈ (s_baseR − s_baseL)/2 within ~1e-9, proceed.
- If |S| != N:
  1) Re-run the same recursion using cached boundarySlope() values but adjust eps_block adaptively:
     - If |S| < N: reduce eps_block by 10× (down to ~1e-12).
     - If |S| > N: increase eps_block by 10×.
     Repeat a few times until |S| stabilizes near N without issuing new queries.
  2) At leaves, compute residual r(a) = |WT(L,L) − w_of(L)|; prefer keeping slopes with smallest residuals. If |S| > N, drop the worst residuals until |S| = N. If |S| < N but some leaf blocks have |WT| > eps_block but failed eps_leaf, add those with smallest residuals until N.
  3) If ambiguity persists, repeat detection with a second X1 (e.g., X1 = 30013) with fresh caches. Intersect or choose consistent slopes across X0 and X1 based on minimal residuals, ensuring |S| = N. This costs extra queries but stays safe under Q_max.
- Never “pad” missing slopes with zeros or arbitrary values. Do not output until you have exactly N slopes.

F) For each detected slope a, locate c = a*X0 + b by a local integer binary search
- Safe bracket beyond window: margin = B + 100 (or larger if necessary).
    center = a*X0
    tL = floor(center − margin − 0.5)
    tR = floor(center + margin − 0.5)
- Compute sL = slopeS_X(tL), sR = slopeS_X(tR). Check (sR − sL)/2 ≈ w_of(a); if significantly smaller (< 0.5*w(a)), expand margin (e.g., B + 1000) once and retry.
- Invariant: In (tL, tR], there is exactly one kink at the unique integer c. For mid m in [tL, tR):
    sM = slopeS_X(m)
    If (sM − sL) > eps_jump (e.g., > 0.5*w(a) is also fine), then the jump has occurred in (tL, m] ⇒ tR = m.
    Else ⇒ kink is in (m, tR] ⇒ tL = m.
  Loop while tR − tL > 1; finalize c = tR (the right endpoint integer).
- Compute b = c − a*X0 (an exact 64-bit integer). Store (a, b).

G) Output format, hygiene, and safety
- Maintain arrays A (slopes) and Bv (intercepts), both length exactly N, corresponding pairwise.
- Do not output anything except protocol lines. No debug prints. Always flush after each query (“? …”) and after the final answer.
- Output exactly:
    ! a_1 a_2 ... a_n b_1 b_2 ... b_n
  followed by newline and flush; then exit.
- Verify total queries used ≤ 10000. Typical costs:
  - Boundary detection: a few hundred boundarySlope calls (each 1 slopeS_X ⇒ 2 g-queries).
  - Each local c-search: ~log2(2*B + 200) ≈ 15 slopeS_X calls ⇒ ~30 g-queries per line.
  Overall for N ≤ 100: safely under Q_max. With multi-way splitting, boundary queries can be drastically reduced to approach ≤ 402 total.

H) Implementation skeleton (must-haves)
- queryXY(ld x, ld y)
- slopeS_X(ll t) with cache
- boundarySlope(int k) with cache
- solve_index_space(L, R, sL, sR, eps_block, out_slopes, optionally record WT residuals)
- find_c_for_slope(a) -> pair<ll c, ll b>
- Driver:
  - Read n.
  - Detect slopes (E) ensuring exactly n.
  - For each slope, locate c and b (F).
  - Print final answer (G).

Common pitfalls you must avoid (these were sources of WA before):
- Do not ever query at y equal to an integer; only t + 0.25 and t + 0.75.
- Do not rely on “closest endpoint” heuristics in binary search; use the explicit Δs jump test against eps.
- Do not pad missing slopes or output an incorrect number of pairs. Ensure exactly N recovered slopes before the final print.
- Ensure flushing after every “?” query and after the final “!” line.
- Use long double consistently; do not downcast to double.
- Keep all coordinates within ±1e12 (satisfied by X0=30011 and |t| up to ~3.1e8).
- Manage caches to avoid recomputation and extra queries.

Optional advanced reduction toward ≤ 402 queries (if time permits):
- Multi-way index partitioning (P≈16..32) per active block level, recursing only into non-empty subblocks.
- Slightly tighter c-search brackets after confirming c is within Ik by sampling inner points.

Your solution must be deterministic, robust to small floating errors, respect the interactive protocol exactly, and terminate with a single correct final answer line containing exactly 2N integers.