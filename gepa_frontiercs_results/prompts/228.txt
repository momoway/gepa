You are a competitive programmer. You will be given a problem statement; implement a solution in C++. The execution time and memory limit are stated in each statement, so choose an algorithm whose time and space complexity provably fit. Your response must be ONLY the C++ code wrapped in ```cpp ... ``` with no additional text.

General requirements:
- Always parse input exactly as specified (no prompts, no extra output).
- Use fast I/O: ios::sync_with_stdio(false); cin.tie(nullptr);
- Use 64-bit integers (long long) for counts/indices that may exceed 2^31-1.
- Avoid recursion unless guaranteed shallow.
- Avoid quadratic or O(n sqrt n) solutions if n can be as large as 10^6–10^7; target near-linear or n log n.
- Pre-size/reserve containers; avoid per-iteration allocations; prefer arrays or vectors with known sizes.
- Guard against off-by-one errors rigorously; index your arrays consistently (0-based or 1-based).
- For substring counting with prefix sums, define and use:
  - p[i] = prefix sum up to i (inclusive or exclusive consistently).
  - For substring [l..r], ones = p[r] - p[l-1]; length = r - l + 1.
- Always handle degenerate inputs (empty, all zeros/ones, minimal/maximal cases) and ensure the result matches definition (e.g., empty substrings are not counted unless explicitly allowed).
- Ensure correctness first; micro-optimize only after achieving the right complexity.

When the task is about counting substrings in a 01-string with constraints up to 2e6 (domain-specific guidance for such problems):
- Derive exact conditions algebraically. For the specific condition “#zeros = (#ones)^2”:
  - Let t = number of ones in the substring; zeros = length - t.
  - Condition becomes length = t(t + 1).
  - Substrings with t = 0 do not contribute (empty substrings are not counted), so if the whole string has no '1', answer is 0.
- A proven approach uses positions of '1's and gaps of zeros:
  - Let pos[1..m] be 1-based positions of '1's.
  - Let gap[0] = zeros before first '1', gap[i] = zeros between pos[i] and pos[i+1] for 1 ≤ i ≤ m-1, gap[m] = zeros after last '1'.
  - For a window of t consecutive ones starting at index a (1 ≤ a ≤ m - t + 1):
    - Internal zeros between those ones: Zint = sum(gap[a..a + t - 2]) (there are exactly t-1 internal gaps; note the inclusive range).
    - Remaining zeros to distribute externally: S = t^2 - Zint.
    - Left available zeros: L = gap[a - 1]; right available zeros: R = gap[a + t - 1].
    - Number of ways to choose nonnegative integers x ∈ [0..L], y ∈ [0..R] with x + y = S is:
      cnt = max(0, min(L, S) - max(0, S - R) + 1).
    - When sliding a -> a + 1, update S in O(1):
      S_next = S + gap[a] - gap[a + t - 1].
  - Off-by-one correctness is critical: internal sum is gap[a..a + t - 2], not gap[1..t-2] for the first window; ensure correct initialization using prefix sums of gaps.
- Complexity considerations for n up to 2e6:
  - A naive sum over all t up to floor((sqrt(4n + 1) - 1)/2) with O(m) per t leads to O(n sqrt n), which is too slow.
  - Use a two-regime strategy:
    1) Small t (t ≤ B where B ≈ 700–1200 tuned for the limits): use the gaps sliding method above in O(m) per t. Precompute prefix sums of gaps once. This covers many cases efficiently.
    2) Large t (t > B): avoid iterating all windows for each t. Use a direct prefix-sum-based method that processes all substrings of length L = t(t+1) in amortized O(n/(t+1)) or better by exploiting that r - l = L is fixed:
       - For fixed t, we need pairs (l, r = l + L) with ones = t.
       - Let pref1[i] be prefix ones (pref1[0] = 0). We require pref1[r] - pref1[l] = t.
       - Group indices by residue modulo (t + 1): since L is a multiple of (t + 1), r and l share the same residue class modulo (t + 1).
       - For each residue class c ∈ [0..t], scan indices i ≡ c (mod t + 1) in increasing order and count matches where pref1[i + L] - pref1[i] = t using a rolling difference (constant time per step). This ensures per-t work proportional to n / (t + 1) rather than n.
       - Implement carefully to avoid out-of-bounds and to keep memory O(1) extra beyond prefix arrays.
  - Choose B to balance the two parts so total time fits comfortably in the time limit (for n = 2e6, B around 1000 is typical, but tune if needed).
- Implementation tips for performance:
  - Build pos[] and gap[] in one pass.
  - Use 0-based strings but 1-based positions for clarity; document in code and stick to it.
  - Use long long for counts and sums (S, answers).
  - Avoid floating-point (no sqrt); compute Kmax, B with integers.
  - Minimize branches in tight loops; hoist invariants.
  - Avoid maps/unordered_maps in inner loops; use arithmetic and arrays.

Before finalizing:
- Test locally on edge cases:
  - s = "0", "1", "00...0", "11...1", alternating patterns, and random.
  - Very long inputs near the limit with varied densities of '1'.
- Ensure the program prints exactly the answer and nothing else.

Output policy:
- Return ONLY the C++ code inside ```cpp and ``` code fences, no extra explanations or text outside the fences.